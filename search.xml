<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python的模块和包]]></title>
    <url>%2F2019%2F05%2F06%2F04.python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. 模块 一个模块就是一个包含pytho代码的文件， 后缀名成是.py就可以，模块就是个python文件 为什么我们用模块 程序太大，编写维护非常不方便，需要拆分 模块可以增加代码重复利用的方式 当做命名空间使用，避免命名冲突 如何定义模块 模块就是一个普通文件，所以任何代码可以直接书写， 不过根据模块的规范，最好在模块中编写以下内容 函数（单一功能） 类（相似功能的组合，或者类似业务模块） 测试代码 如何使用模块 模块直接导入 语法 123import module_namemodule_name.function_namemodule_name.class_name 假如模块名称直接以数字开头，需要借助importlib帮助 123456789# 借助于importlib包可以实现导入以数字开头的模块名称import importlib# 相当于导入了一个叫01的模块并把导入模块赋值给了tulingtuling = importlib.import_module(&quot;01&quot;)stu = tuling.Student()stu.say() - import 模块 as 别名 - from module_name import func_name, class_name - 按上述方法有选择性的导入 - 使用的时候可以直接使用导入的内容，不需要前缀 - from module_name import * - 导入模块所有内容 if __name__ == &quot;__main__ 的使用 可以有效避免模块代码被导入的时候被动执行的问题 建议所欲程序的入口都以此代码为入口 2. 模块的搜索路径和存储 什么是模块的搜索路径： 加载模块的时候，系统会在那些地方寻找此模块 系统默认的模块搜索路径 import sys sys.path 属性可以获取路径列表 # 案例 p06.py import sys print( type(sys.path )) print( sys.path ) for p in sys.path: print(p) 添加搜索路径 sys.path.append(dir) 模块的加载顺序 搜索内存中已经加载好的模块 搜索python的内置模块 搜索sys.path路径 包 包是一种组织管理代码的方式，包里面存放的是模块- 用于将模块包含在一起的文件夹就是包 自定义包的结构 |---包 |---|--- __init__.py 包的标志文件 |---|--- 模块1 |---|--- 模块2 |---|--- 子包(子文件夹) |---|---|--- __init__.py 包的标志文件 |---|---|--- 子包模块1 |---|---|--- 子包模块2 包的导入操作 import package_name 直接导入一个包，可以使用init.py中的内容 使用方式是： package_name.func_name package_name.class_name.func_name() - import package_name as p - 具体用法跟作用方式，跟上述简单导入一致 - 注意的是此种方法是默认对__init__.py内容的导入 - import package.module - 导入包中某一个具体的模块， - 使用方法 package.module.func_name package.module.class.fun() package.module.class.var - import package.module as pm from … import 导入 from package import module1, module2, module3, ….. 此种导入方法不执行__init__的内容 from pkg01 import p01 p01.sayHello() from package import * 导入当前包 __init__.py文件中所有的函数和类 使用方法 func_name() class_name.func_name() class_name.var from package.module import * 导入包中指定的模块的所有内容 使用方法 func_name() class_name.func_name() 在开发环境中经常会所以用其他模块，可以在当前包中直接导入其他模块中的内容 import 完整的包或者模块的路径 __all__ 的用法 在使用from package import 的时候， 可以导入的内容 __init__.py中如果文件为空， 或者没有 __all__， 那么只可以把__init__中的内容导入 __init__ 如果设置了__all__的值，那么则按照__all__ 指定的子包或者模块进行加载如此则不会载入__init__中的内容 __all__=[&#39;module1&#39;, &#39;module2&#39;, &#39;package1&#39;.........] 命名空间 用于区分不同位置不同功能但相同名称的函数或者变量的一个特定前缀 作用是防止命名冲突 setName() Student.setName() Dog.setName()]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的面向对象]]></title>
    <url>%2F2019%2F04%2F25%2F03.python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[OOP-Python面向对象 Python的面向对象 OO 类的基本实现 类和对象的成员分析 self 面向对象编程 基础 公有私有 继承 多态、Mixin 类的相关函数、类的成员描述符、类的内置属性 魔法函数 类和对象的三种方法 抽象类 自定义类 Python的面向对象1. 面向对象概述（ObjectOriented，OO） OOP思想 接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的 几个名词 OO:面向对象 OOA：面向对象的分析 OOD：面向对象的设计 OOI：xxx的实现 OOP：xxx的编程 OOA-&gt;OOD-&gt;OOI: 面向对象的实现过程 类和对象的概念 类：抽象名词，代表一个集合，共性的事物 对象：具象的事物，单个个体 类跟对象的关系 一个具象，代表一类事物的某一个个体 一个是抽象，代表的是一大类事物 类中的内容，应该具有两个内容 表明事物的特征，叫做属性(变量) 表明事物功能或动作， 称为成员方法(函数) 2. 类的基本实现 类的命名 遵守变量命名的规范 大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词跟单词直接相连） 尽量避开跟系统命名相似的命名 你如何声明一个类 必须用class关键字 类由属性和方法构成，其他不允许出现 成员属性定义可以直接使用变量赋值，如果没有纸，许使用None 实例化类 变量 = 类名() #实例化了一个对象 访问对象成员 使用点操作符 obj.成员属性名称 obj.成员方法 可以通过默认内置变量检查类和对象的所有成员 对象所有成员检查 # dict前后各有两个下划线 obj.__dict__ 类所有的成员 # dict前后各有两个下划线 class_name.__dict__ 3. 类和对象的成员分析 类和对象都可以存储成员，成员可以归类所有，也可以归对象所有 类存储成员时使用的是与类关联的一个对象 独享存储成员是是存储在当前对象中 对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员， 如果对象中有此成员，一定使用对象中的成员 创建对象的时候，类中的成员不会放入对象当中，而是得到一个空对象，没有成员 1234567891011121314151617181920212223242526class A(): name = &quot;kobe&quot; number = 24# A 称为类实例 print (&quot;A&quot;,A.name,id(A.name))print (&quot;A&quot;,A.number,id(A.number))print(&quot;*&quot; * 20)a = A()print (&quot;a&quot;,a.name,id(a.name))print (&quot;a&quot;,a.number,id(a.number))# 查看所有的属性print (&quot;A&quot;,A.__dict__)print (&quot;a&quot;,a.__dict__) #&#123;&#125; 空 # 在不对对象的实例属性赋值的前提下，类实例的属性和其对象实例的属性指向同一个变量A kobe 140589649254976A 24 9306720********************a kobe 140589649254976a 24 9306720A &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;kobe&apos;, &apos;number&apos;: 24, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None&#125;a &#123;&#125; 通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员 123456789101112131415161718192021222324252627282930313233343536373839class A(): name = &quot;kobe&quot; number = 24 # A 称为类实例 print (&quot;A&quot;,A.name,id(A.name))print (&quot;A&quot;,A.number,id(A.number))print(&quot;*&quot; * 20)a = A()print (&quot;a&quot;,a.name,id(a.name))print (&quot;a&quot;,a.number,id(a.number))## 查看所有的属性print (&quot;A&quot;,A.__dict__)print (&quot;a&quot;,a.__dict__) #&#123;&#125; print(&quot;*&quot; * 20)#赋值a.name = &quot;Owen&quot;a.number = 11print (&quot;a&quot;,a.name,id(a.name))print (&quot;a&quot;,a.number,id(a.number))print (&quot;a&quot;,a.__dict__)#通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员A kobe 140589649254976A 24 9306720********************a kobe 140589649254976a 24 9306720A &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;kobe&apos;, &apos;number&apos;: 24, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None&#125;a &#123;&#125;********************a Owen 140589649496696a 11 9306304a &#123;&apos;name&apos;: &apos;Owen&apos;, &apos;number&apos;: 11&#125; 4. 关于self self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法的第一个参数中 self并不是关键字，只是一个用于接受对象的普通参数，理论上可以用任何一个普通变量名代替 123456789101112131415161718class Student(): name = &quot;dana&quot; age = 18 # 注意say的写法，参数有一个self def say(self): self.age = 200 print(&quot;My age is &#123;0&#125;&quot;.format(self.age)) # 任何一个普通变量名代替self def sayAgain(s): print(&quot;My age is &#123;0&#125;&quot;.format(s.age)) yueyue = Student()yueyue.say()yueyue.sayAgain()My age is 200My age is 200 方法中有self形参的方法是非绑定类的方法，可以通过对象访问； 没有self的是绑定类的方法，只能通过类访问 类方法中需要访问当前类的成员，可以通过 class成员名来访问 12345678910111213141516171819202122232425262728class Teacher(): name = &quot;dana&quot; age = 19 def say(self): self.name = &quot;yaona&quot; self.age = 17 print(&quot;My name is &#123;0&#125;&quot;.format(self.name)) # 调用类的成员变量需要用 __class__ print(&quot;My age is &#123;0&#125;&quot;.format(__class__.age)) def sayAgain(): print(__class__.name) print(__class__.age ) print(&quot;Hello, nice to see you again&quot;) t = Teacher()t.say()# 调用绑定类函数使用类名Teacher.sayAgain()# 如果类方法中需要访问当前类的成员，可以通过 __class__成员名来访问My name is yaonaMy age is 19dana19Hello, nice to see you again 1234567891011121314151617181920212223242526272829303132333435363738394041# 关于self的案例class A(): name = &quot; liuying&quot; age = 18 def __init__(self): self.name = &quot;aaaa&quot; self.age = 200 def say(self): print(self.name) print(self.age) class B(): name = &quot;bbbb&quot; age = 90a = A()# 此时，系统会默认把对象a作为第一个参数传入函数a.say() A.say() #错误，类实例不会自动传入第一个参数，需要手动传入一个# 此时，self被a替换A.say(a)# 同样可以把A作为参数传入A.say(A)# 此时，传入的是类实例B，因为B具有name和age属性，所以不会报错A.say(B)# 以上代码，利用了鸭子模型aaaa200aaaa200 liuying18bbbb90 面向对象编程面向对象的三大特性 封装 继承 多态 1 封装 将属性和方法封装到一个抽象的类中 封装的三个级别： 公开，public 受保护的，protected 私有的，private public，private，protected不是关键字 判别对象的位置 对象内部 对象外部 子类中 python中下划线使用 私有 私有成员是最高级别的封装，只能在当前类或对象中访问 在成员前面添加两个两个下划线即可 12345class Person(): # name是共有的成员 name = &quot;liuying&quot; # __age就是私有成员 __age = 18 Python的私有不是真私有，是一种成为name mangling的改名策略可以使用:对象._classname_attributename访问 1234567891011# __age是私有变量,不能直接访问。print(p.__age) #注意报错信息# name mangling技术 print(Person.__dict__)p._Person__age = 19print(p._Person__age)&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;liuying&apos;, &apos;_Person__age&apos;: 18, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Person&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Person&apos; objects&gt;, &apos;__doc__&apos;: None&#125;19 受保护的封装 protected 受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都可以进行访问，但是在外部不可以 封装方法： 在成员名称前添加一个下划线即可 name mangling的改名策略可以使用:对象._classname_attributename访问 公开的，公共的 public 公共的封装实际对成员没有任何操作，任何地方都可以访问 2 继承 继承就是一个类可以获得另外一个类中的成员属性和成员方法 作用： 减少代码，增加代码的复用功能， 同时可以设置类与类直接的关系 继承与被继承的概念： 被继承的类叫父类，也叫基类，也叫超类 用于继承的类，叫子类，也叫派生类 继承与被继承一定存在一个 is-a 关系 继承的语法: 12#父类写在括号内class Teacher(Person): 继承的特征 所有的类都继承自object类，即所有的类都是object类的子类 子类一旦继承父类，则可以使用父类中除私有成员外的所有内容 子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用 子类中可以定义独有的成员属性和方法 子类中定义的成员和父类成员如果相同，则优先使用子类成员 子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用，可以使用[父类名.父类成员]的格式来调用父类成员，也可以使用super().父类成员的格式来调用 1234567891011121314151617181920212223242526272829303132# 子类扩充父类功能的案例# 人由工作的函数， 老师也由工作的函数，但老师的工作需要讲课class Person(): name = &quot;NoName&quot; age = 18 __score = 0 # 考试成绩是秘密，只要自己知道 _petname = &quot;sec&quot; #小名，是保护的，子类可以用，但不能公用 def sleep(self): print(&quot;Sleeping ... ...&quot;) def work(self): print(&quot;make some money&quot;) #父类写在括号内class Teacher(Person): teacher_id = &quot;9527&quot; name = &quot;DaNa&quot; def make_test(self): print(&quot;attention&quot;) def work(self): # 扩充父类的功能只需要调用父类相应的函数 #Person.work(self) # 扩充父类的另一种方法 # super代表得到父类 super().work() self.make_test() t = Teacher()t.work()make some moneyattention 继承变量函数的查找顺序问题 优先查找自己的变量 没有则查找父类 构造函数如果本类中没有定义，则自动查找调用父类构造函数 如果本类有定义，则不在继续向上查找 构造函数 是一类特殊的函数，在类进行实例化之前进行调用 12345678910111213# 构造函数的概念class Dog():# __init__就是构造函数# 每次实例化的时候，第一个被自动的调用# 因为主要工作是进行初始化，所以得名 def __init__(self): print(&quot;I am init in dog&quot;)# 实例话的时候，括号内的参数需要跟构造函数参数匹配kaka = Dog()I am init in dog 如果定义了构造函数，则实例化时使用构造函数，不查找父类构造函数 如果没定义，则自动查找父类构造函数 如果子类没定义，父类的构造函数带参数，则构造对象时的参数应该按父类参数构造 super super不是关键字， 而是一个类 super的作用是获取MRO（MethodResolustionOrder）列表中的第一个类 super于父类直接没任何实质性关系，但通过super可以调用到父类 super使用的两个方法,参见在构造函数中调用父类的构造函数 单继承和多继承 单继承：每个类只能继承一个类 多继承，每个类允许继承多个类 单继承和多继承的优缺点 单继承： 传承有序逻辑清晰语法简单隐患少呀 功能不能无限扩展，只能在当前唯一的继承链中扩展 多继承： 优点：类的功能扩展方便 缺点：继承关系混乱 菱形继承/钻石继承问题 多个子类继承自同一个父类，这些子类由被同一个类继承，于是继承关系图形成一个菱形图谱 MRO 关于多继承的MRO MRO就是多继承中，用于保存继承顺序的一个列表 python本身采用C3算法来多多继承的菱形继承进行计算的结果 MRO列表的计算原则： 子类永远在父类前面 如果多个父类，则根据继承语法中括号内类的书写顺序存放 如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中第一个父类的父类 12345678910111213141516171819202122232425262728293031323334353637383940414243案例：扩展构造函数class A(): def __init__(self): print(&quot;A&quot;)class B(A): def __init__(self, name): print(&quot;B&quot;) print(name) class C(B): # c中想扩展B的构造函数， # 即调用B的构造函数后在添加一些功能 # 由两种方法实现 &apos;&apos;&apos; # 第一种是通过父类名调用 def __init__(self, name): # 首先调用父类构造函数 B.__init__(self, name) # 其次，再增加自己的功能 print(&quot;这是C中附加的功能&quot;) &apos;&apos;&apos; # 第二种，使用super调用 def __init__(self, name): # 首先调用父类构造函数 super(C, self).__init__(name) # 其次，再增加自己的功能 print(&quot;这是C中附加的功能&quot;) # 此时，首先查找C的构造函数# 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止# 此时，会出现参数结构不对应错误c = C(&quot;我是C&quot;)B我是C这是C中附加的功能 3 多态 不同的子类对象调用相同的父类方法，产生不同的执行结果 以继承和重写父类方法为前提 多态性：同一种调用方式，产生不同的执行效果 多态和多态性 Mixin设计模式 主要采用多继承方式对类的功能进行扩展 Mixin概念 MRO and Mixin Mixin模式 Mixin MRO MRO 我们使用多继承语法来实现Minxin 使用Mixin实现多继承的时候非常小心 首先他必须表示某一单一功能，而不是某个物品 职责必须单一，如果由多个功能，则写多个Mixin Mixin不能依赖于子类的实现 子类及时没有继承这个Mixin类， 也能照样工作，只是缺少了某个功能 优点 使用Mixin可以在不对类进行任何修改的情况下，扩充功能 可以方便的组织和维护不同功能组件的划分 可以根据需要任意调整功能类的组合 可以避免创建很多新的类，导致类的继承混乱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Mixin案例class Person(): name = &quot;liuying&quot; age = 18 def eat(self): print(&quot;EAT.......&quot;) def drink(self): print(&quot;DRINK......&quot;) def sleep(self): print(&quot;SLEEP.....&quot;) class Teacher(Person): def work(self): print(&quot;Work&quot;)class Student(Person): def study(self): print(&quot;Study&quot;) class Tutor(Teacher, Student): passt = Tutor() print(Tutor.__mro__)print(t.__dict__)print(Tutor.__dict__)print(&quot;*&quot;*20)class TeacherMixin(): def work(self): print(&quot;Work&quot;)class StudentMixin(): def study(self): print(&quot;Study&quot;) class TutorM(Person, TeacherMixin, StudentMixin): passtt = TutorM()print(TutorM.__mro__)print(tt.__dict__)print(TutorM.__dict__) 4 类相关函数 issubclass:检测一个类是否是另一个类的子类 isinstance:检测一个对象是否是一个类的实例 hasattr:检测一个对象是否由成员xxx getattr: get attribute setattr: set attribute delattr: delete attribute dir: 获取对象的成员列表 5 类的成员描述符（属性） 类的成员描述符是为了在类中对类的成员属性进行相关操作而创建的一种方式 get： 获取属性的操作 set：修改或者添加属性操作 delete： 删除属性的操作 如果想使用类的成员描述符，大概有三种方法 使用类实现描述器 使用属性修饰符 使用property函数 property函数很简单 property(fget, fset, fdel, doc) 12345678910111213141516171819# peroperty案例# 定义一个Person类，具有name，age属性# 对于任意输入的姓名，我们希望都用大写方式保存# 年龄，我们希望内部统一用整数保存# x = property(fget, fset, fdel, doc)class Person(): # 函数的名称可以任意 def fget(self): return self._name * 2 def fset(self, name): # 所有输入的姓名以大写形式保存 self._name = name.upper() def fdel(self): self._name = &quot;NoName&quot; name2 = property(fget, fset, fdel, &quot;对name进行下下操作啦&quot;) 无论哪种修饰符都是为了对成员属性进行相应的控制 类的方式： 适合多个类中的多个属性共用用一个描述符 property：使用当前类中使用，可以控制一个类中多个属性 属性修饰符： 使用于当前类中使用，控制一个类中的一个属性 6 类的内置属性__dict__:以字典的方式显示类的成员组成 __doc__: 获取类的文档信息 __name__:获取类的名称，如果在模块中使用，获取模块的名称 __bases__: 获取某个类的所有父类，以元组的方式显示 7 类的常用魔术方法 魔术方法就是不需要人为调用的方法，基本是在特定的时刻自动触发 魔术方法的统一的特征，方法名被前后各两个下滑线包裹 操作类 __init__: 构造函数 __new__: 对象实例化方法，此函数较特殊，一般不需要使用 __call__: 对象当函数使用的时候触发 __str__: 当对象被当做字符串使用的时候调用 __repr__: 返回字符串 描述符相关 __set__ __get__ __delete__ 属性操作相关 __getattr__: 访问一个不存在的属性时触发 __setattr__: 对成员属性进行设置的时候触发 参数： self用来获取当前对象 被设置的属性名称，以字符串形式出现 需要对属性名称设置的值 作用：进行属性设置的时候进行验证或者修改 注意： 在该方法中不能对属性直接进行赋值操作，否则死循环 12345678910111213141516# __setattr__案例class Person(): def __init__(self): pass def __setattr__(self, name, value): print(&quot;设置属性： &#123;0&#125;&quot;.format(name)) # 下面语句会导致问题，死循环 #self.name = value # 此种情况，为了避免死循环，规定统一调用父类魔法函数 super().__setattr__(name, value) p = Person()print(p.__dict__)p.age = 18 运算分类相关魔术方法 __gt__: 进行大于判断的时候触发的函数 参数： self 第二个参数是第二个对象 返回值可以是任意值，推荐返回布尔值 待补充。。123456789101112131415161718#实例：class Student(): def __init__(self, name): self._name = name def __gt__(self, obj): print(&quot;哈哈， &#123;0&#125; 会比 &#123;1&#125; 大吗？&quot;.format(self, obj)) return self._name &gt; obj._name stu1 = Student(&quot;one&quot;)stu2 = Student(&quot;two&quot;)print(stu1 &gt; stu2)哈哈， &lt;__main__.Student object at 0x7f4aac6b3b00&gt; 会比 &lt;__main__.Student object at 0x7f4aac6b3ac8&gt; 大吗？False 8 类和对象的三种方法 实例方法 需要实例化对象才能使用的方法，使用过程中可能需要截止对象的其他对象的方法完成 静态方法 不需要实例化，通过类直接访问 类方法 不需要实例化 123456789101112131415161718192021222324252627282930# 三种方法的案例class Person: # 实例方法 def eat(self): print(self) print(&quot;Eating.....&quot;) #类方法 # 类方法的第一个参数，一般命名为cls，区别于self @classmethod def play(cls): print(cls) print(&quot;Playing.....&quot;) # 静态方法 # 不需要用第一个参数表示自身或者类 @staticmethod def say(): print(&quot;Saying....&quot;) yueyue = Person()# 实例方法yueyue.eat()# 类方法Person.play()yueyue.play()#静态方法Person.say()yueyue.say() 9 抽象类 抽象方法： 没有具体实现内容的方法成为抽象方法 抽象方法的主要意义是规范了子类的行为和接口 抽象类的使用需要借助abc模块 import abc 抽象类：包含抽象方法的类叫抽象类，通常成为ABC类 12345678910111213141516171819202122232425# 抽象类的实现import abc#声明一个类并且指定当前类的元类class Human(metaclass=abc.ABCMeta): # 定义一个抽象的方法 @abc.abstractmethod def smoking(self): pass # 定义类抽象方法 @abc.abstractclassmethod def drink(): pass # 定义静态抽象方法 @abc.abstractstaticmethod def play(): pass # 定义一个具体方法 def sleep(self): print(&quot;Sleeping.......&quot;) 抽象类的使用 抽象类可以包含抽象方法，也可以包含具体方法 抽象类中可以有方法也可以有属性 抽象类不允许直接实例化 必须继承才可以使用，且继承的子类必须实现所有继承来的抽象方法 假定子类没有是现实所有继承的抽象方法，则子类也不能实例化 抽象类的主要作用是设定类的标准，以便于开发的时候具有统一的规范 10 自定义类12345678# 函数名可以当变量使用def sayHello(name): print(&quot;&#123;0&#125;你好 &quot;.format(name)) sayHello(&quot;月月&quot;)B = sayHelloB(&quot;yueyue&quot;) 类其实是一个类定义和各种方法的自由组合 可以定义类和函数，然后自己通过类直接赋值 1234567891011121314151617# 组装类 1 class A(): passdef say(self): print(&quot;Saying... ...&quot;) #等同于 class B(): def say(self): print(&quot;Saying......&quot;)say(9)A.say = saya = A()a.say() 可以借助于MethodType实现 123456789101112131415# 组装类例子 2# 自己组装一个类from types import MethodTypeclass A(): passdef say(self): print(&quot;Saying... ...&quot;) a = A()# 通过MethodType 把say组装到A a.say = MethodType(say, A)a.say() 借助于type实现 1234567891011121314151617# 利用type造一个类# 先定义类应该具有的成员函数def say(self): print(&quot;Saying.....&quot;) def talk(self): print(&quot;Talking .....&quot;) #用type来创建一个类A = type(&quot;AName&quot;, (object, ), &#123;&quot;class_say&quot;:say, &quot;class_talk&quot;:talk&#125;)# 然后可以像正常访问一样使用类a = A()a.class_say()a.class_talk() 利用元类实现- MetaClass 元类是类 被用来创造别的类12345678910111213141516171819# 元类演示# 元类写法是固定的，必须继承自type# 元类一般命名以MetaClass结尾class TulingMetaClass(type): # 注意以下写法 def __new__(cls, name, bases, attrs): #自己的业务处理 print(&quot;哈哈，我是元类呀&quot;) attrs[&apos;id&apos;] = &apos;000000&apos; attrs[&apos;addr&apos;] = &quot;北京海淀区公主坟西翠路12号&quot; return type.__new__(cls, name, bases, attrs) # 元类定义完就可以使用，使用注意写法class Teacher(object, metaclass=TulingMetaClass): passt = Teacher()t.id]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的流程控制]]></title>
    <url>%2F2019%2F04%2F23%2F02.python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[流程控制 分支结构 循环结构 函数 分支结构/选择结构1 单项分支1234 if 条件表达式： ... ``` ## 2 双向分支 if 条件表达式: …else: …1234特征： 1) 双向分支有2个区间，分别是True控制的if区间(真区间)和False控制的else区间(假区间) 2) if区间内容必须完全缩进，否则出现语法问题 ## 3 多项分支 if 条件表达式： …elif 条件表达式: …elif 条件表达式： …else: …12345特征: 1) 无论什么样的分支，有多少个分支，分支结构只会执行其中一个分支，然后就会结束分支结构 2) 多项分支的条件判断是自上而下逐个判断的，True就执行这个分支，False就不执行这个分支 ## 4 巢状分支 巢状分支就是多个其他if...else分支的嵌套组合。 if x &lt; 5: print(‘x真的小于5哦’) if y &lt; 6: print(‘如果y &lt; 6，我会被输出’) elif y &gt; 6: print(‘如果上y大于6，我会被输出’)elif x &gt; 5: print(‘x大于5’)12345678910111213141516171819注意：：在python中并没有switch...case分支。后期可以使用字典和函数的组合来代替。# 循环结构 ## 1 while循环``` 1）格式1： while 条件表达式: ... 2）格式2：while 条件表达式： ... else: ... 3）死循环:while True: ... 2 for循环for … in 循环123456789101112131） 格式1: for 变量 in 序列: ... 2） 格式2:for 变量1,变量2.. in 多层序列： ... 3） 格式3：for 变量 in 序列：: ...else: ... 3 其他流程控制语句 break 破坏，结束，打破作用：结束程序循环，一旦程序执行了break语句，那么当前break所在的循环就会被终止。 continue 继续作用：结束本次循环，开始下一次的循环，他不会终止整个循环，仅对于循环中的某次循环有效 pass 通过，忽略作用：在程序结构中有时不需用写任何python内容，但是如果没有内容，语言结构会出现语法错误！pass可以作为语法占位符使用，pass语句没有任何意义，也不会做任何操作 函数1 函数的特征 函数的定义必须使用def关键字 函数不调用不会被执行 1.1 最基本的函数结构123def 函数名()： ...调用函数： 函数名() 1.2 具有参数的函数结构123def 函数名(参数名，参数名...): ...调用函数: 函数名(值,值...) 声明函数的()中的参数称之为形参，形参表示形式上的参数调用函数的()中的参数称之为实参，实参表示真实的值注意:实参传递值给形参的过程，本质上就是普通的变量赋值 1.3 具有默认值参数的函数12345def 函数名(形参名 = 默认值,形参名 = 默认值...): ...调用函数1：函数名()调用函数2:函数名(实参,实参...) 注意:具有默认值的函数，调用时如果不提供实参，则会使用形参的默认值执行，如果提供了实参，则使用实参而忽略默认值 1.4 函数文档 查看函数文档：1) 使用help(函数名)，可以查看函数文档信息，查看信息时信息会换行2) 使用函数名.doc的方式查看，查看信息时信息不会换行，会显示\n3) 自定义函数文档： 在函数内部开始的第一行使用字符串定义文字内容即可123456789101112131415def 函数名()： &apos;此处书写函数文档信息，单引号中使用\n换行&apos; 函数中的其他代码...或者def 函数名(): &apos;&apos;&apos; 此处书写函数文档信息 此处书写函数文档信息 ... 函数中的其他代码... 1.5 lambda表达式lambda表达式就是一种简洁格式的函数而已。lambda不是一种函数结构，只是一种表达式而且不需要函数名。（匿名函数）格式： 变量 = lambda 形参,形参...： 功能代码 案例：123lambda x,y :x*y #传入两个参数返回这两个数的乘积 lambda x： 值1 if 条件表达式 else 值2#根据条件表达式的真假返回值1还是值2 优点：1.lambda表达式书写简单，不用def关键字，可惜要用lambda2.lambda表达式不需要函数名，省得命名头疼3.看起来比较装逼！ 缺点：1.lambda表达式功能受限，无法使用循环以及部分流程控制相关语句2.lambda表达式不适合较为复杂的程序。 2 关键字参数1234def 函数名(形参名 = 默认值,形参名 = 默认值...): ... 调用函数：函数名(形参名 = 实参值,形参名 = 实参值...) 优点:由于实参和形参传递是按照位置一一对应的关系，当参数太多时容易出现参数传错位置的情况 引入关键字参数后，在设置实参时可以指定形参的名称，避免参数传递错误！ 2.1 收集参数 收集参数1 (专用于收集非关键字参数)123def 函数名(*形参名)： ... 调用函数： 函数名(实参,实参....) 12345注意: 1) 使用收集参数进行形参的书写，需要在形参名之前添加* 2) *形参格式的收集参数会收集到调用函数时传入的所有没有关键字的形参 3) 收集参数收集到的最终数据是由所有非关键字实参组成的元组。4) 收集参数和普通的参数（关键字参数）可以共存 收集参数2 (专门用于收集关键字参数)123def 函数名(**args): ...调用函数：函数名(形参名 = 值,形参名=值...) 12345注意1) 使用收集参数收集关键字实参的方法需要在形参名之前加** 2) **形参格式会收集调用函数时传入函数的所有关键字参数 3) 收集的所有关键字参数最终组成的数据为字典类型 4) 关键字参数收集的方式可以和普通形参共存，但是必须在最后 注意1：普通形参，非关键字收集形参和关键字收集形参具有顺序关系普通形参放最前面非关键字形参放中间关键字形参放最后注意2：所有收集参数只能够收集没有形参接受的实参 2.2 函数的变量作用域全局变量:在函数外部声明的变量就是全局变量局部变量:在函数内部声明的变量就是局部变量 局部变量和全局变量的作用范围1) 全局变量在全局范围内可以使用2) 全局变量在局部范围内可以使用(访问)3) 局部变量在局部范围内可以使用4) 局部变量在全局范围内无法正常使用 global 关键字global 关键字的作用是提升局部变量为全局变量1234def 函数名(): ... #提升局部变量为全局变量 global 局部变量 全局变量和局部变量同名在此情况下,局部环境中只会使用局部变量,忽略同名的全局变量 2.3 内部函数在函数内部声明的函数就是内部函数特征:1) 内部函数在函数内部可以访问2) 内部函数的调用必须在定义内部函数之后3) 内部函数不可以在函数外部调用4) 本质上内部函数等同于内部变量 2.4 闭包闭包就是将函数内部的局部变量或者内部函数,弄到函数外,并且可以正常使用的特殊方法.突破了局部作用域的限制!注意:闭包少用!闭包格式：1234567def 外层函数()： 局部变量 局部变量 def 内部函数()： pass return (局部变量，局部变量...内部函数,内部函数...) 2.5 nonlocal关键字nonlocal的作用是声明当前变量不是当前函数内部的变量，他有可能是当前函数的外部变量（不是全局变量） 123456789101112def 外部函数() 局部变量 def 内部函数（）: nonlocal 变量名#声明当前变量不是内部函数中的变量 其他代码... return 代码 2.6 递归函数在函数中调用当前函数本身的函数就是递归函数。 示例：12345678910111213def recursion(n): #输出当前的n的值 print(n) #判断n的值是否&gt;0,决定下一步操作 if n&gt;0: #n&gt;0 在此调用当前函数digui，将n - 1放进去 recursion(n-1) else: #n&gt;0 为False 输出分隔线 print(&apos;------&apos;) #再次输出n的值 print(n) recursion(3) 执行结果: 3 2 1 0 ----- 0 1 2 3]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的语法基础]]></title>
    <url>%2F2019%2F04%2F21%2F01.python%E7%9A%84%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[python 语法基础 基础语法 数据类型及其内置函数 字符串的格式化 数据类型的内置函数 表达式和运算符 0.0 基础语法 编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 变量 变量的声明var_name = var_valuevar1 = var2 = var3 = var_valuevar1,var2,va3 = v1,v2,v3 python中变量值的互换两个变量交换值操作a,b = b,a 查看数据类型 使用type()函数用法：type(变量名) 获取变量在内存中的id标识 使用id()函数用法：id(变量名) 系统中保留关键字： 查看方式：import keywordkeyword.kwlist 多行语句Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句，例如： 12345678total = item_one + \ item_two + \ item_three 在 [], &#123;&#125;, 或 () 中的多行语句，不需要使用反斜杠(\)，例如：total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;, &apos;item_four&apos;, &apos;item_five&apos;] 等待用户输入：(input()) 同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割。 1234实例(Python 3.0+)#!/usr/bin/python3 import sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;) Python的数据类型Python中可以自定义数据类型,可以具有无限种数据类型。系统默认提供6个标准数据类型： Number类型(数字) String类型（字符串） List类型 (列表) tuple类型(元组) Dictionary类型(字典) Set类型（集合） 1 Number类型Number类型主要包含数学相关的数据：一共分为4种小类型： 整型整型就是整数。包括正整数负整数和0二进制（0b开头）变量 = 0b10101八进制（0o开头）变量 = 0o777十进制（不需要）变量 = 250十六进制（0x开头）变量 = 0xabcd 浮点型浮点型就是小数。使用小数表示浮点数 float1 = 3.141592653科学计数法表示浮点数float2 = 314e-2 # 314*10的-2次方 复数什么是复数。 复数由实数和虚数两部分组成，其中真正存在的数字就是实数，假定一个数的平方=-1 那么这个数就是虚数的基本单位表达式方式：163+2j 这就是一个典型的复数使用复数功能结构com2 = complex(15,3) 布尔类类型布尔值就是表示确定或者否定的数据类型，只有2个值：True和False 在python当中没有真正的布尔类型，而是使用数字0来表示False，数字1表示True，所以bool是Number类型 2 String类型字符串就是文字类型 2.1 字符串的声明： 单引号声明字符串 变量 = ‘值’ 双引号声明字符串 变量 = “值” 三引号声明变量 变量 = ‘’’值’’’ 或者 变量 = “””值””” 三引号声明字符串的方式适合大数据的字符串，多行数据都适合 2.2 字符串相关操作12345+ 字符串连接符号* 字符复制操作 &apos;★&apos; × 10 复制10个小星星[] 通过指定位置（索引）来获取指定位置的字符 [:] 取片操作（不包含结束位置） 12注意事项： 单引号中不可以直接使用单引号 双引号中不可以直接使用双引号 三引号中可以随意使用单双引号 字符串的转义操作：(在行尾时) 续行符\ 反斜杠符号\’ 单引号\” 双引号\a 响铃\b 退格(Backspace)\e 转义\000 空\n 换行\v 纵向制表符\t 横向制表符\r 回车\f 换页\oyy 八进制数，yy代表的字符，例如：\o12代表换行\xyy 十六进制数，yy代表的字符，例如：\x0a代表换行\other 其它的字符以普通格式输出 12#防止转义:在字符串前面添加一个r print(r&apos;hello\nrunoob&apos;) 2.3 str 的内置函数capitalize() 首字母大写格式： str.capitalize()返回值：首字母大写的字符串，仅把整个字符串的第一个字符大写 upper() 将所有英文字符变为大写格式：str.upper()返回值：返回所有英文字符大写的字符串 lower（） 将所有英文字符变为小写格式：str.lower()返回值：返回所有英文字符小写的字符串 swapcase() 大小写互相转换格式：str.swapcase()返回值：转换之后的字符串 title() 按照标题格式进行大小写转换（每个单词首字母大写)格式：str.title()返回值：返回所有英文单词首字母大写的字符串 len() 计算字符串的字符个数,以后也可以用于计算元组列表等序列格式: len(str)返回值:整型 count() 计算一个字符串中出现指定字符串的次数格式：str.count(‘查找的字符串’[,开始位置])返回值:返回整型 find() 查找字符串中是否具有指定的字符串，==查找不到返回-1==格式：str.find(查找的字符串[，开始位置])返回值:第一次出现的位置 index() 查找字符串中是否具有指定的字符串，==查找不到直接报错==格式：str.index(查找的字符串[，开始位置])返回值:第一次出现的位置 注意：find()和index()功能基本相似 startswith() 检测字符串是否以指定的字符串开头格式： str.startswith(‘查找的字符串’[，开始位置])返回值：布尔值 endswith() 检测字符串是否以指定的字符串结尾格式： str.endswith(‘查找的字符串’[，开始位置])返回值：布尔值 isupper() 检测字符串中字母是否都是大写字母格式：str.isupper()返回值：布尔值 islower()检测字符串中的字母是否都是小写字母格式：str.islower()返回值：布尔值 isalnum() 检测一个字符串是否都是有数字或者是否都是有字母组成格式：str.isalnum()返回值:布尔值注意：空字符串返回False isalpha() 检测字符串是否都是有字母类型构成，汉字作为字母处理格式：str.isalpha()返回值：布尔值注意：空字符串返回False isdigit() 检测字符串是否由纯数字字符组成格式：str.isdigit()返回值：布尔值注意：空字符串返回False isspace() 检测字符串是否完全由空白字符组成格式：str.isspace()返回值：布尔值注意：回车，换行，缩进，空格都可以当作空白字符，空字符串是False istitle() 检测字符串是否符合title()的结果，每个单词首字母大写格式：str.istitle()返回值：布尔值 isnumeric() 检测字符串是否有纯数字构成格式：str.isnumeric()返回值：布尔值 isdecimal(）检测字符串是否完全由十进制字符组成格式：str.isdecimal()返回值：布尔值 split() 使用指定的字符将字符串卷拆解成多个字符串格式： str.split(‘用于拆解的字符串’)返回值：列表类型 splitlines() 使用\n，\r或者\r\n切割字符串格式：str.splitlines()返回值：列表类型 join() 使用指定的字符串将序列中的内容组成新的字符串格式：连接字符串.join(序列)返回值：组成的新的字符串 zfill() 0填充操作格式： str.zfill(长度)返回值：填充0的字符串注意：1.填充结果原有内容靠右对齐，前面位数不足使用0来补充，常用于数字类型字符串。 center() 将字符串进行居中操作，并且在空白处进行填充格式： str.center(未来字符宽度,空白填充字符)返回值：新的字符串 ljust（） 将字符串进行左对齐操作，并且在空白处进行填充格式： str.ljust(未来字符宽度,空白填充字符)返回值：新的字符串 rjust() 将字符串进行右对齐操作，并且在空白处进行填充格式： str.rjust(未来字符宽度,空白填充字符)返回值：新的字符串 lstrip() 去掉字符串左侧的空白格式： str.lstrip()返回值：字符串 rstrip()去掉字符串右侧的空白格式： str.rstrip()返回值：字符串 strip()去掉字符串两侧的空白格式： str.strip()返回值：字符串 replace() 字符串替换操作格式： str.replace(被替换的字符串,替换字符串)返回值：替换之后的字符串、 maketrans() 制作一个字符串映射表，为了给translate函数使用格式:str.maketrans（’被替换的字符串’,’替换字符串’）返回值：字典类型，被替换字符串组成键，替换字符串组成值注意： 两个参数的字符串个数必须一一对应，这里的str不是值字符串，而是真正的str，也可以写空字符串代替str（字符串都是str制作的） translate() 进行字符串翻译操作，类似转换格式：str.translate(映射表)返回值:新的字符串注意:translate用于多字符替换，replace用于长字符串替换 2.4 string模块相关内容获取所有的空白字符result = string.whitespaceprint(result) \n \r \t \x0b\x0c 获取ascii码的所有字母表（包含大写和小写）print(string.ascii_letters) 获取ascii码中的所有大写字母print(string.ascii_uppercase) 获取ascii码中所有的小写字母print(string.ascii_lowercase) 获取ascii码中所有10进制数字字符print(string.digits) 获取八进制所有数字字符print(string.octdigits) 获取十六进制的所有数字字符print(string.hexdigits) 打印所有可见字符print(string.printable) 打印所有标点符号print(string.punctuation) 3 List类型 (列表)3.1 列表格式：变量 = [值,值,值….]列表的标志符号是[] 列表的访问操作1）列表变量：[索引位置]2）添加列表操作：不可以使用索引方式添加3）修改列表操作：列表变量[索引位置] = 新值4）删除列表操作：del 列表变量[索引位置] 3.2 列表的序列操作序列操作包括：索引，分片，序列相加，序列相乘，成员检测，最大值，最小值，长度计算 索引操作格式： 列表变量[索引] 分片操作 列表 = [值,值,值…] 方法1：列表[:] 表示获取列表的所有数据 方法2：列表[开始索引：] 表示丛开始索引位置截取到列表的最后 方法3:列表[:结束索引] 表示从列表的开头截取到结束索引位置之前，不包含结束位置 方法4:列表[开始索引:结束索引] 表示从列表的开始索引位置截取到结束索引位置之前，，不包含结束位置 方法5：列表[开始索引:结束索引:跳步值] 表示从开始索引位置到结束索引位置之间，不包含索引位置，并且获取数据时索引每次+跳步值来获取，默认跳步值为1 序列相加格式：列表 = 列表1 + 列表2 列表相乘格式： 列表 = 列表1 * 整数结果：将列表重复N分组成新的列表注意： 数字必须为整数 成员资格运算格式：数据 in 列表作用：检测数据是否在列表当中返回值：布尔值 格式：数据 not in 列表作用：检测数据是不是不再列表当中返回值：布尔值 3.3 列表的遍历 for … in 遍历 12for i in 列表: print(i) while循环遍历 12345length = len(列表)i = 0while i &lt; length: print(列表[i]) i += 1 双层列表循环列表 = [[值1,值2],[值1,值2]，[值1,值2]…]格式： for 变量1,变量2 in 列表： 可以使用变量1和变量2 3.4 列表内涵： list content 简单的列表内涵：格式：[[变量 for [变量 in 列表]作用：遍历列表中的数据并且组成新的列表，如果需要改变原有数据，在最开始i处修改即可结果：新的列表 带有判断的列表内涵格式 [变量 for 变量 in 列表 判断条件]作用：遍历列表中的数据，根据判断条件取出符合条件的数据组成新的列表结果:新的列表 多循环带判断的列表内涵格式：[[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2]作用：将列表1中的每个数据和列表2的每个数据进行相加操作，此处可以使用别的操作（变量1+变量2 仅为参考）结果：新的列表 格式：[[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2 判断条件]作用：将列表1中和列表2中每个数据进行操作，但是必须在符合判断条件的前提下进行。结果：新的列表 3.5 序列函数len() 获取列表的数据长度格式：len(列表)返回值：整型 max() 获取列表中的最大值格式：max(列表)返回值：列表中的最大值 min() 获取列表的最小值格式：min(列表)返回值：列表中的最小值 list() 将其他序列类型转化为列表格式：list(序列)返回值：列表 3.6 列表专用函数append() 在列表的最后追加新数据格式： 列表.append(数据)返回值：无注意：该操作直接改变原有列表 insert() 在列表指定的位置插入数据格式：列表.insert（索引,数据）返回值：无注意：该操作直接改变原有列表 pop() 在列表中移除一个元素格式：列表.pop()返回值:移除掉的元素注意：移除列表最后的元素 格式：列表.pop(索引)返回值：:移除掉的元素注意：移除列表中指定索引的元素无论哪种格式都直接改变原有列表 remove() 在列表中移除指定的值的元素格式:列表.remove(值)返回值：无注意：该操作直接改变原有列表 clear() 清空列表格式：列表.clear()返回值：无注意：该操作直接改变原有列表 reverse() 列表反转格式：列表.reverse（）返回值：无注意：该操作直接改变原有列表 extend() 在原有列表最后追加新的序列格式:列表.extend(序列类型)返回值： 无注意：该操作直接改变原有列表 count() 计算指定值在列表中出现的次数格式: 列表.count(值)返回值：整数 copy() 复制原有列表格式: 列表.copy()返回值：新的列表 4 tuple类型(元组)元组不具备修改功能。 是一种特殊的列表。 4.1 元组的操作 创建元组1） 创建空元组变量 = ()2） 创建单个数据的元组变量 = (值,) 或 变量 = 值,3） 创建多个数据的元组变量 = (值,值，值…) 或者 变量 = 值,值，值…注意： 元组的关键符号是逗号而不是小括号。 4.2 序列操作索引，分片，序列相加，序列相乘，成员资格 索引操作元组[索引位置] 分片操作元组[:] 获取元素的所有数据元组[开始索引:] 获取开始索引位置到最后的所有数据元组[:结束索引] 获取元组开头到结束索引位置之前的所有数据（不包含结束位置）元组[开始索引:结束索引] 获取元素开始索引位置到结束索引位置之间的所有数据（不包含结束位置）元组[开始索引:结束索引:跳步值] 获取元素开始位置到结束索引之间的指定间隔的数据数据（不包含结束位置） 相加操作新元组 = 元组 + 元组 相乘操作新元组 = 元组 * 整数 成员检测数据 in 元组检测数据是否在元组当中，在返回True，不再返回False 数据 not in 元组检测数据是否不再元组当中，不再返回True，在返回False 4.3 元组的遍历 普通元组的遍历 123for 变量 in 元组： 使用变量 多层元组的遍历 123for 变量1,变量2 in 元组： 使用变量 4.4 元组的函数len() 获取元组中数据的长度格式： len(元组)返回值：整数 max() 返回元组中最大的值格式：max(元组) min() 返回元组中的最小值格式：min(元组) tuple() 将其他序列转化为元组类型格式： tuple(任意序列) 4.5 元组的方法count() 计算指定数据出现的次数格式:元组.count(查找的数据)返回值：整数 index() 获取指定值在元组中的索引位置格式：元组.index(查找的数据)返回值：索引位置或者错误信息 变量交换 （元组特殊用法）a,b = b,a 5 Dictionary类型(字典)字典类型就是一个完整的数据由键和值组成的多数据的组合，没有顺序 字典格式：变量 = {键:值,键:值….}键就是标志或者说是目录值就是真实的值字典的标志符号是{} 5 字典-dict5.1 字典的创建 创建空字典变量 = {} 或者 变量 = dict() 创建有数据的字典1） 变量 = {键:值,键:值,键:值…}2） 变量 = dict({键:值,键:值,键:值…})3） 变量 = dict(键=值,键=值,键=值…)注意：该方法键的名称要符合变量的基本名规则4） 变量 = dict([(键,值),(键,值),（键,值）…])5） 变量 = dict(zip((键，键，键….),(值,值，值…))) 5.2 字典的特征 字典也是序列类型但是是无序序列，所以分片操作无法使用 字典中每个数据都由键和值两部分组成： 值：任意数据都可以当作值来使用 键：可以使用 int，float,str,tuple，冰冻集合，但是list，set，dict等不可以使用 5.3 字典的基本操作 访问数据：字典变量[键] 添加数据字典变量[新键] = 值 修改数据字典变量[键] = 新值 删除数据del 字典变量[键] 5.4 序列操作1234567数据 in 字典 检测数据是否在字典的键中数据 not in 字典 检测数据是否不再字典的键中 5.5 遍历操作 键遍历操作 12for 变量 in 字典: 使用变量(变量就是字典中的键) 键值遍历 12for 键变量,值变量 in 字典.items()： 使用键变量和值变量 5.6 字典内涵 基本的字典内涵变量= {key:value for key,value in 字典.items()} 带有条件的字典内涵变量 = {key:value for key,value in 字典.items() if 条件} 5.7 字典函数len() 计算字典的长度格式： len(字典)返回值:字典的长度 max() 获取字典中的最大值 （默认比较字典的键）格式:max(字典)返回值：最大的键 min() 获取字典中的最小值（默认比较字典的键）格式：min(字典)返回值:最小值 dict() 将其他序列转化为字典详情请看字典的定义 str(字典) 返回字典的字符串格式 5.8 字典方法clear() 清空字典格式：字典.clear()返回值：无 None注意：直接改变原有字典 items() 获取字典的键值对组成的元组格式格式：字典.items()返回值：将键值对变成元组的列表形式。 注意:返回的数据是内建的dict_items类型，专用于字典的转换中间类型 keys() 获取字典中所有键组成的序列，常用语字典遍历格式： 字典.keys()返回值:返回所有键的组合 注意：类型为 dict_keysL类型，也是一种字典转换的中间类型 values() 获取字典中所有值组成的序列，常用语字典遍历格式： 字典.values()返回值：所有值的组合注意：类型为dict_values类型，也是一种字典转换的中间类型 get（） 根据指定的键获取值格式：字典.get(键,默认值)返回值：字典键对应的数据注意：如果键不存在与字典中，则返回默认值而不会报错 pop() 根据键从字典中删除数据格式:字典.pop(键)返回值：删除的键对应的值注意：pop在字典中使用必须有参数，因为字典无序序列，直接改变原有字典 copy() 赋值一个字典格式：字典.copy()返回值：复制出来的新的字典 setdefault() 设置字典中不存在的键的值格式：字典.setdefault(键,默认值)返回值：设置时的默认值注意：如果设置时键已经存在于字典中，则不进行任何操作，直接改变原有字典 fromkeys() 使用指定的序列作为键,使用一个值作为字典的所有值格式:字典.fromkeys(序列,值)返回值：由序列作为字典的键，由值作为所有键对应的值组成的字典 update() 使用字典更新另外一个字典格式：字典1.update(字典2)返回值：无注意:直接改变原有字典 6 Set类型（集合）集合就是一组数据的无序组合。集合中的数据永远是唯一的数据 6.1 集合的创建 创建空集合变量 = set() 创建多个数据的集合变量 = {值,值,值….}注意：集合是内部元素绝对唯一的数据，所以集合中出现多个相同数据时只会保留一份 6.2 集合的特征 集合是一种无序的数据类型，无法通过索引和分片进行操作 集合是内部元素绝对唯一的数据，常常用于去掉重复数据-集合的数据，str，int，float,bool,tuple，冰冻集合。 6.3 集合序列操作 成员检测操作1234567数据 in 集合 检测数据是否在集合当中数据 not in 集合 检测数据是否不在集合当中 6.4 集合遍历操作 普通集合遍历 1234集合 = &#123;值,值，值....&#125;for 变量 in 集合： 使用变量 带有元组的集合遍历 1234集合 = &#123;（值1,值2..）,(值3,值4..)...&#125;for 变量1,变量2.. in 集合: 使用变量1和变量等 6.5 集合内涵 普通集合内涵新集合 = {变量 for 变量 in 集合} 带条件的集合内涵新集合 = {变量 for 变量 in 集合 if 条件} 多循环的集合内涵新集合 = {变量1+变量2 for 变量1 in 集合1 for 变量2 in 集合2 if 条件} 6.6 集合函数len() 获取集合中元素的个数格式:len(集合)返回值：整数 max() 获取集合中最大的元素格式:max(集合)返回值：集合中最大的值 min() 获取集合中最小的元组格式：min(集合)返回值：集合中的最小值 set() 将其他序列转化为集合类型格式：set(序列)返回值：集合类型 6.7 集合方法add() 向集合中添加数据格式： 集合.add(数据)返回值：无注意：直接改变原有集合，已存在的数据无法添加 clear() 清空集合格式：集合.clear()返回值：无注意：直接改变原有集合 copy() 集合复制格式:集合.copy()返回值:原集合所有数据组成的新的集合 remove() 移除指定的值格式:集合.remove(值)返回值：无注意：直接改变原有集合，如果要删除的值不存在，就报错 discard()移除集合中指定的值格式:集合.discard(值)返回值：无注意：直接改变原有集合，如果要删除的值不存在，就不作任何操作 pop() 随机移除一个元素格式：集合.pop（）返回值：被移除的元素注意：随机移除元素，没啥规律 intersection() 计算两个值集合之间的交集格式： 集合1.intersection(集合2)返回值：新的集合 difference() 计算两个集合之间的差集格式： 集合1.difference(集合2)返回值:新的集合 union() 计算两个集合之间的并集操作格式：集合1.union（集合2）返回值：新的集合 issubset() 检测一个集合是否是另外一个集合的子集格式：集合1.issubset(集合2)返回值：布尔值 issuperset() 检测一个集合是否是另外一个和集合的超集格式：集合1.issuperset(集合2)返回值：布尔值 difference_update（） 计算集合1和集合2的差集并且将结果赋值给集合1格式：集合1.difference_update(集合2)返回值:无注意：操作结果直接赋值给集合1 intersection_update() 计算集合1和集合2的交集并且将结果赋值给集合1格式：集合1.intersection_update(集合2)返回值：无注意:操作结果直接赋值给集合1 update() 计算集合1和集合2的并集并且将并集结果赋值给集合1格式：集合1.update(集合2)返回值:无注意:操作结果直接赋值给集合1 6.8 冰冻集合/固定集合 frozen 冰冻集合就是不可以进行任何修改相关操作的集合 创建冰冻集合1） 创建空的冰冻集合变量 = frozenset()2） 创建具有数据的冰冻集合变量 = fronzenset(一个序列) 操作方法和函数冰冻集合的操作相关函数和方法同集合类型一样。只是不可以使用修改集合相关的方法和函数。注意:frozenset 和普通的集合一样没有什么本质区别，能够使用的函数数量不一样，仅此而已哦 7 数据类型转换数据类型转换分为两大类： 自动类型转换类型转换会向着更加精确的类型进行转换 强制类型转换强制类型转换是根据程序需要，由程序员通过操作强制改变数据的类型。 int（） 强制将数据转化为整型① 纯数字字符串转化为整型时，类型改变，值不变② 只有纯整数字符串才可以转换，其他均不可以③ 浮点型可以转化为整型，去掉小数点后面的部分 float() 强制将数据转化为浮点型① 整数字符串和浮点数字符串均可以转化为浮点型② 转化过程中类型改变，值不变③ 整型也可以用于浮点型转换 complex（） 生成一个复数 bool() 强制将数据转化为布尔值能够转化为布尔值False的情况：① 字符串 空字符串 ② 整型 0 ③浮点型 0.0 ④ 复数 0+0j ⑤ 布尔值 Flase ⑥ 列表 [] 空列表 ⑦ 元组 () 空元组 ⑧ 字典 {} 空字典 ⑨ 集合 set（）空集合 str() 字符串类型转换所有数据类型都可以转换为字符串，转换规则就是在原有数据基础上加了引号变成了字符串的格式。例如：[1，2，3] =“[1，2，3]” list() 将其他数据转换为列表类型能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） tuple() 将其他数据类型转换为元组类型能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） dict() 将其他数据转化为字典类型字典类型转换可以转化的类型有三种：list 、tuple 、set以上所有类型的每个数据必须由元组组成，并且每个元组必须有2个值 例子：{(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)}[(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)]((‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)) set() 集合类型转换能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） 字符串的格式化 利用百分号 % 利用format函数 1 利用百分号格式化 %d 此处应该放入一个整数 %s 放入一个字符串 1234s = "i love %s"print (s)print ("i love %s"%"KI")print (s%"KIOVEN") i love %s i love KI i love KIOVEN 12345s = "i am %d years old"print (s%18)# 如果出现多个占位符，则相应内容需要用括号括起来s = "i am %s,i am %d years old"print (s%("ouwen",18)) 12i am 18 years oldi am ouwen,i am 18 years old 2 利用format格式化 123456# 在使用上，以&#123;&#125;和： 代替%号，后面用format带参数完成s = 'i love &#123;&#125;'.format("you")print (s)s = "i am &#123;1&#125; years old,i love &#123;0&#125; and &#123;1&#125; years old".format("tulingxueyuan",24)print (s) 12i love youi am 24 years old,i love tulingxueyuan and 24 years old 表达式和运算符1 表达式由变量、运算符、数字、数字分组符号（括号）等以能求得数值的有意义排列方法所得的组合。 2 运算符的分类 算术运算 比较运算/关系运算 赋值运算 逻辑运算 位运算 成员运算 身份运算 2.1 算数运算+ - * / %(取余) //(地板除，取商) **幂运算 注意： python中没有自增自减的 ++ 或者– 运算 混合计算时，Python会把整型转换成为浮点数 2.2 比较运算== ！= &gt; &lt; &gt;= &lt;= 注意：在python中没有 === 和 ！==运算，只要类型不同就是不等于 2.3 赋值运算= += -= *= /= //= **= 注意：a = b 转换之后的表达式为 a = a b 无论何种赋值运算都符合这个格式 2.4 逻辑运算逻辑运算是布尔值之间的运算and 与运算：有假则假or 或运算：有真则真not 非运算:真变假，假变真 2.5 位运算位运算就是在二进制基础上进行的逻辑运算，将0视为False，将1视为True进行的运算 &amp; 按位与运算 | 按位或运算 ～ 按位非运算注意：按位非运算之后计算机会进行反码和补码的相关操作之后进行数据存储 ^ 按位抑或运算:将数据转化为2进制数据然后进行每个位上的逻辑抑或运算变量 = 值1 ^ 值2 左移运算:将数据转化为二进制之后，将二进制数据的所有数据向左移动指定的位数变量 = 值 &lt;&lt; 移动位数特征：左移N位相当于乘以2的N次方，此方法速度远高于乘法 右移运算将数据转化为二进制之后，将二进制数据的所有数据向右移动指定的位数，如果数据移除右侧边界，则会被删除，实际上相当于采用了地板除！变量 = 值 &gt;&gt; 移动位数特征：右移N位相当于除以2的N次方，舍弃小数部分。此方法速度远高于除法 2.6 成员运算 in 检测一个值在指定的序列类型里面格式： 值 in 可迭代序列 not in 检测一个值是否不再指定的序列里面格式： 值 not in 可迭代序列 2.7 身份运算1） is 检测值1是不是和值2在内存中是否是同一个值，类似id()功能格式: 数据1 is 数据22） is not 检测值1是不是和值2在内存中是否不是同一个值，类似id()功能格式: 数据1 is not 数据2 2.8 检测数据归属1) type() 测试时可以使用，开发尽量避免使用格式：type(变量)2) isinstance() 检测一个数据是否由指定的类型创建格式：isinstance(变量，检测的类型) 2.9 运算优先级问题1234567891011121314** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 'AND' ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 注意：我们并不推荐死记硬背优先级，在实际使用中最好使用()解决优先级问题]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
